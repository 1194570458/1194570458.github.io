{"meta":{"title":"Kason的博客","subtitle":"个人博客","description":"记录享受技术的过程","author":"Kason Li","url":"https://1194570458.github.io","root":"/"},"pages":[{"title":"About me","date":"2020-04-20T01:08:52.000Z","updated":"2020-04-20T01:09:11.766Z","comments":true,"path":"about/me.html","permalink":"https://1194570458.github.io/about/me.html","excerpt":"","text":"关于我只是一个小小程序员"}],"posts":[{"title":"什么是Synchronized进阶版","slug":"什么是Synchronized进阶版","date":"2020-05-28T03:00:02.000Z","updated":"2020-05-28T03:23:32.150Z","comments":true,"path":"2020/05/28/什么是Synchronized进阶版/","link":"","permalink":"https://1194570458.github.io/2020/05/28/%E4%BB%80%E4%B9%88%E6%98%AFSynchronized%E8%BF%9B%E9%98%B6%E7%89%88/","excerpt":"","text":"Synchronized1. 常见面试题请描述synchrnoized和reentrantlock的底层实现及重入的底层原理 - 百度 阿里 请描述锁的四种状态和升级过程 - 百度 阿里 CAS的ABA问题如何解决 - 百度 请谈一下AQS，为什么AQS的底层是CAS + volatile - 百度 请谈一下你对volatile的理解 - 美团 阿里 volatile的可见性和禁止指令重排序是如何实现的 - 美团 CAS是什么 - 美团 请描述一下对象的创建过程 - 美团 顺丰 对象在内存中的内存布局 - 美团顺丰 DCL单例为什么要加volatile - 美团 解释一下锁的四种状态 - 顺丰 Object 0 = new Object()在内存中占了多少字节? - 顺丰 请描述synchronized和ReentrantLock的异同 - 顺丰 聊聊你对as -if- serial和happens- before语义的理解 - 京东 你了解ThreadLocal吗?你知道ThreadL ocal中如何解决内存泄漏问题吗? - 请描述一下锁的分类以及JDK中的应用 - 阿里 问:自旋锁一-定比重量级锁效率高吗? - 阿里 打开偏向锁是否效率一定会提升? 为什么? 2. 什么是CAScompare and swap compare and exchange 比较和交换，多线程中，不加锁就可以修改一个值。修改值之前先比较旧的值，如果旧的值没有改变，就可以修改新的值。 2.1. ABA问题 有一个变量A的值为1 线程一读取变量A的值为1 线程二读取变量A的值为1，然后修改为2 线程三读取变量A的值为2，然后修改为1 这时候线程一想把变量A的值修改为2，比较变量A的值仍然为1，没问题，然后把变量A修改为2（你的女朋友经历了别的男人，但是你依然发现不了，觉得这还是原来的女朋友） 2.1.1. 如何解决加一个版本号，每修改一次，版本号也跟着修改，而且不重复 2.2. CAS最终的汇编代码多个处理器下加 lock 指令 最终实现 cmpxchg = cas 修改变量值 1lock cmpxchg 指令 3. 用户态与内核态JDK早期，synchronized 叫做重量级锁，因为申请锁资源必须通过kernel, 系统调用 12345678910111213141516171819;he11o.asm ;write(int fd, const void *buffer, size_t nbytes)section data msg db &quot;He11o&quot;, 0xA 1en equ $ - msg section .textgloba1 _start_start: mov edx, len mov ecx, msg mov ebx, 1 ;文件描述符1 std_out mov eax, 4 ;write函数系统调用号 4 int 0x80 mov ebx, 0 mov eax, 1 ;exit函 数系统调用号 int 0x80 4. 对象内存布局(markword)针对Hotspot JVM虚拟机 new一个对象{m=8} 8个字节 markword 4个字节 内存指针 4个字节 成员变量 字节对齐 5. 工具：JOL = Java Object Layout1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt; &lt;artifactId&gt;jol-core&lt;/artifactId&gt; &lt;version&gt;0.10&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 5.1. 测试123456public class HelloJOL &#123; public static void main(String[] args) &#123; Object o = new Object(); System.out.println(ClassLayout.parseInstance(o).toPrintable()); &#125;&#125; 输出 5.2. 加锁后测试12345678910public class HelloJOL &#123; public static void main(String[] args) &#123; Object o = new Object(); System.out.println(ClassLayout.parseInstance(o).toPrintable()); synchronized (o)&#123; System.out.println(ClassLayout.parseInstance(o).toPrintable()); &#125; &#125;&#125; 输出 锁信息保存在markword 6. synchronized的横切面详解6.1. java源码层级12345678910public class HelloJOL &#123; public static void main(String[] args) &#123; Object o = new Object(); System.out.println(ClassLayout.parseInstance(o).toPrintable()); synchronized (o)&#123; System.out.println(ClassLayout.parseInstance(o).toPrintable()); &#125; &#125;&#125; 6.2. 字节码层级MONITORENTER：上锁 MONITOREXIT：释放锁 12345678910111213141516171819202122232425262728293031323334353637// access flags 0x9 public static main([Ljava/lang/String;)V TRYCATCHBLOCK L0 L1 L2 null TRYCATCHBLOCK L2 L3 L2 null L4 LINENUMBER 11 L4 NEW java/lang/Object DUP INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V ASTORE 1 L5 LINENUMBER 13 L5 ALOAD 1 DUP ASTORE 2 MONITORENTER //上锁 L0 LINENUMBER 15 L0 ALOAD 2 MONITOREXIT // 释放锁 L1 GOTO L6 L2 ASTORE 3 ALOAD 2 MONITOREXIT // 发生异常退出后释放锁 L3 ALOAD 3 ATHROW L6 LINENUMBER 16 L6 RETURN L7 LOCALVARIABLE args [Ljava/lang/String; L4 L7 0 LOCALVARIABLE o Ljava/lang/Object; L5 L7 1 MAXSTACK = 2 MAXLOCALS = 4 6.3. JVM层级（Hotspot）InterpreterRuntime:: monitorenter方法 1234567891011121314151617181920212223IRT_ENTRY_NO ASYNC(void, InterpreterRuntime::monitorenter(JavaThread* thread,BasicobjectLock* e1em))#ifdef ASSERTthread-&gt;last_frame().interpreter._frame_verify_monitor(elem) ;#endif if (PrintBiasedLockingstatistics) &#123; Atomic::inc(BiasedLocking::s1ow_path_entry_count_addr()); &#125; Handle h_obj(thread, elem-&gt;obj()); assert(Universe::heap()-&gt;is_in_reserved_or_nu11(h_obj()), \"must be NULL or an object\"); if (UseBiasedLocking) &#123; // Retry fast entry if bias is revoked to avoid unnecessary inflation ObjectSynchronizer::fast_enter(h_obj, e1em-&gt;1ock())， true, CHECK); &#125; else &#123; Objectsynchronizer::s1ow_enter(h_obj，e1em-&gt;1ock())， CHECK); &#125; assert(Universe::heap(-&gt;is_in_reserved_or_nu11(e1em-&gt;obj()), \"must be NULL or an object\");#ifdef ASSERT thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);#endifIRT_END 7. 锁升级过程7.1. JDK8 markword实现表 自旋锁什么时候升级为重量级锁？ 竞争加剧:有线程超过10次自旋，-XX:PreBlockSpin， 或者自旋线程数超过CPU核数的一半，1.6之后， 加入 自适应自旋Adapative Self Spinning，JVM自己控制 为什么有自旋锁还要重量级锁？ 自旋是消耗CPU资源的，如果锁得时间长，或者自旋线程多，CPU会被大量消耗 重量级锁有等待队列，所有拿不到锁得进入等待队列，不需要消耗CPU资源 偏向锁是否一定比自旋锁效率高? 不一定，在明确知道会有多线程竞争得情况下，偏向锁肯定会涉及锁撤销，这时候直接使用自旋锁 JVM启动过程，会有很多线程竞争（明确），所以默认情况启动时不打开偏向锁，过一段时间再打开 -XX:BiasedLockingStartupDelay=0 new -偏向锁-轻量级锁(无锁, 自旋锁，自适应自旋) - 重量级锁 synchronized优化的过程和markword息息相关 用markword中最低的三位代表锁状态其中1位是偏向锁位两位是普通锁位 Object 0 = new Object() 锁=0 01无锁态 注意:如果偏向锁打开，默认是匿名偏向状态 o.hashCode( 001 + hashcode 1200000001 10101101 00110100 0011011001011001 00000000 00000000 00000000 little endian big endian 00000000 00000000 00000000 01011001 00110110 00110100 10101101 00000000 默认synchronized(o) 00-&gt;轻量级锁 默认情况偏向锁有个时延，默认是4秒 why?因为IVM虚拟机自己有一一些默认启动的线程， 里面有好多sync代码,这些sync代码启动时就知道肯定会 有竞争，如果使用偏向锁，就会造成偏向锁不断的进行锁撤销和锁升级的操作,效率较低。 1-XX:BiasedLockingStartupDelay&#x3D;0 如果设定上述参数 new Object() -&gt; 101偏向锁 -&gt;线程ID为0 -&gt; Anonymous BiasedLock 打开偏向锁，new出来的对象，默认就是一个可偏向匿名对象101 如果有线程上锁 上偏向锁，指的就是,把markword的线程ID改为自己线程ID的过程 偏向锁不可重偏向批量偏向批量撤销 如果有线程竞争 撤销偏向锁，升级轻量级锁 线程在自己的线程栈生成L ockRecord，用CAS操作将markword设置为指向自己这个线程的LR的指针，设置 成功者得到锁 如果竞争加剧 竞争加剧:有线程超过10次自旋，-XX:PreBlockSpin， 或者自旋线程数超过CPU核数的一半，1.6之后， 加入 自适应自旋Adapative Self Spinning，JVM自己控制 升级重旱级锁: -&gt; 向操作系统申请资源，linux mutex , CPU从3级-0级系统调用，线程挂起，进入等待队列， 等待操作系统的调度,然后再映射回用户空间 (以上实验环境是JDK11,打开就是偏向锁，而JDK8默认对象头是无锁)偏向锁默认是打开的，但是有一一个时延，如果要观察到偏向锁，应该设定参数 如果计算过对象的hashCode,则对象无法进入偏向状态! 轻量级锁重量级锁的hashCode存在与什么地方? 答案:线程栈中，轻量级锁的LR中，或是代表重量级锁的ObjectMonitor的成员中 关于epoch: (不重要) 批量重偏向与批量撤销 渊源:从偏向锁的加锁解锁过程中可看出，当只有一个线程反复进入同步块时，偏向锁带来的性能开销基本可以忽略，但是当有其他线程尝试获得锁时，就需要等到safe point时，再将偏向锁撤销为无锁状态或升级为轻量级，会消耗一定的性能， 所以在多线程竞争频繁的情况下，偏向锁不仅不能提高性能，还会导致性能下降。于是，就有了批量重偏向与批量撤销的机制。 原理以class为单位，为每个class维护解决场景批量重偏向(bulk rebias)机制是为了解决:一个线程创建了大量对象并执行了初始的同步操作,后来另-个线程也来将这些对象作为锁对象进行操作,这样会导致大量的偏向锁撤销操作。批量撤销(bulk revoke)机制是为了解决:在明显多线程竞争剧烈的场景下使用偏向锁是不合适的。 一个偏向锁撤销计数器，每一-次该class的对象发生偏向撤销操作时，该计数器+1,当这个值达到重偏向阈值(默认20)时，JVM就认为该class的偏向锁有问题，因此会进行批量重偏向。每个class对象会有一个对应的epoch字段，每个处于偏向锁状态对象的Mark Word中也有该字段,其初始值为创建该对象时class中的epoch的值。每次发生批量重偏向时，就将该值+1, 同时遍历JVM中所有线程的栈，找到该class所有正处于加锁状态的偏向锁，将其epoch字段改为新值。下次获得锁时，发现当前对象的epoch值和lass的epoch不相等,那就算当前已经偏向了其他线程，也不会执行撤销操作,而是直接通过CAS操作将其Mark Word的Thread Id改成当前线程ld.当达到重偏向阈值后，假设该class计数器继续增长,当其达到批量撤销的阈值后(默认40)，JVM就认为该class的使用场景存在多线程竞争，会标记该class为不可偏向，之后，对于该class的锁，直接走轻量级锁的逻辑。 7.2. 锁重入synchronized是可重入锁 重入次数必须记录，因为要解锁几次必须得对应 偏向锁 -&gt; 线程栈 -&gt; LR + 1 重量级锁 -&gt; ? ObjectMonitor字段上","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://1194570458.github.io/tags/JVM/"},{"name":"Java","slug":"Java","permalink":"https://1194570458.github.io/tags/Java/"},{"name":"Synchronized","slug":"Synchronized","permalink":"https://1194570458.github.io/tags/Synchronized/"}]},{"title":"什么是Synchronized","slug":"什么是Synchronized","date":"2020-05-25T16:24:35.000Z","updated":"2020-05-25T16:28:48.234Z","comments":true,"path":"2020/05/26/什么是Synchronized/","link":"","permalink":"https://1194570458.github.io/2020/05/26/%E4%BB%80%E4%B9%88%E6%98%AFSynchronized/","excerpt":"","text":"Synchronized复习一下Synchronized用法Synchronzied锁定的是对象，而不是代码 123456789101112131415161718public class T &#123; private static Object o = new Object(); public static void main(String[] args) &#123; synchronized (o) &#123; System.out.println(\"Hello!\"); &#125; &#125; public synchronized void m()&#123;// synchronized (this) &#125; public static synchronized void n()&#123;// synchronized (T.class) &#125;&#125; 字节码的实现在Idea运行以上代码，然后View-&gt; ShowBytecode 注意：监视器（monitor） MONITORENTER MONITOREXIT 123456789101112131415161718192021222324252627282930313233343536public static main([Ljava/lang/String;)V TRYCATCHBLOCK L0 L1 L2 null TRYCATCHBLOCK L2 L3 L2 null L4 LINENUMBER 16 L4 GETSTATIC top/kason/test/T.o : Ljava/lang/Object; DUP ASTORE 1 MONITORENTER // 上锁 L0 LINENUMBER 17 L0 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; LDC \"Hello!\" INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V L5 LINENUMBER 18 L5 ALOAD 1 MONITOREXIT // 释放锁 L1 GOTO L6 L2 FRAME FULL [[Ljava/lang/String; java/lang/Object] [java/lang/Throwable] ASTORE 2 ALOAD 1 MONITOREXIT // 释放锁 发生异常后释放锁 L3 ALOAD 2 ATHROW L6 LINENUMBER 19 L6 FRAME CHOP 1 RETURN L7 LOCALVARIABLE args [Ljava/lang/String; L4 L7 0 MAXSTACK = 2 MAXLOCALS = 3 JVM的实现（Hostpot）从锁到锁升级的故事：《没错，我就是厕所所长》 加锁，指的是锁定对象 对象在内存中的存储布局 对象头 类型指针 实例数据 对齐 在64位的虚拟机上，对象头部占8个字节 实例数据：存放类的属性数据信息，包括父类的属性信息； 对齐填充：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐； 对象头：Java对象头一般占有2个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit，在64位虚拟机中，1个机器码是8个字节，也就是64bit），但是 如果对象是数组类型，则需要3个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。 Mark Word 锁的升级过程JDK较早的版本，锁是利用到OS的资源（互斥量），每次都要经历 用户态-&gt;内核态的转换【开销较大，重量级，效率比较低】 现代版本进行了优化：无锁-&gt;偏向锁-&gt;轻量级锁（自旋锁）-&gt;重量级锁 初创对象（64位） unused25 (identity)hashcode31 unused1 分代年龄age4 是否偏向锁1位（初创对象0：不是偏向锁） 锁标志位2位 调用synchronized(对象)过程：无锁升级为偏向锁偏向锁 - markword上记录当前线程指针，下次同一个线程加锁的时候，不需要争用，只需要判断线程指针是否同一个，所以，偏向锁，偏向加锁的第一个线程，hastCode备份在线程栈上，线程销毁，锁降级为无锁 第一次调用 查询锁标志位-&gt;01-&gt;查询是否偏向锁（不是偏向锁 0）-&gt;设置为偏向锁（偏向锁 1）并记录线程ID（抹掉hashcode）-&gt;加锁成功 第二次调用（同线程） 检查线程ID是否自己-&gt;是则加锁成功 偏向锁升级为轻量锁有争用 - 锁升级为轻量级锁 - 每个线程有自己的LockRecord在自己的线程栈上，用CAS去争用markword的LR的指针，指针指向哪个线程的LR，哪个线程就拥有锁 每个线程调用，查询锁标志位，发现是偏向锁，则开辟自己线程栈中的内存，记录偏向锁的内容，修改mark word记录偏向锁的内容，指向自己线程栈中记录的指针（CAS替换）。如果成功修改指针，则成功获取到锁。 如果修改指针失败，则开始自旋，自旋10次后自动升级为重量级锁 （-XX:+PreBlockSpin 来指定次数） 轻量锁升级为重量锁自施超过10次，升级为重星级锁-如果太多线程自旋CPU消耗过大，不如升级为重量级锁，进入等待队列(不消耗CPU) mark word指向monitor对象（C++对象）-&gt;线程阻塞并进入EntryList 锁的效率问题偏向锁由于有锁撒销的过程revoke,会消耗系统资源，所以，在锁争用特别激烈的时候，用偏向锁未必效率高。还不如直接使用轻量级锁。 C++的实现操作系统的一些辅助类和数据结构 CPU的实现https://blog.csdn.net/21aspnet/article/details/88571740使用lock comxchg实现 Synchronized vs Lock（CAS）123456在高争用 高耗时的环境下synchronized效率更高在低争用 低耗时的环境下CAS效率更高synchronized到重量级之后是等待队列 (不消耗CPU)CAS (等待期间消耗CPU)一切以压测为准","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://1194570458.github.io/tags/JVM/"},{"name":"Java","slug":"Java","permalink":"https://1194570458.github.io/tags/Java/"},{"name":"Synchronized","slug":"Synchronized","permalink":"https://1194570458.github.io/tags/Synchronized/"}]},{"title":"什么是redis","slug":"什么是redis","date":"2020-05-23T13:46:28.000Z","updated":"2020-05-23T13:48:35.416Z","comments":true,"path":"2020/05/23/什么是redis/","link":"","permalink":"https://1194570458.github.io/2020/05/23/%E4%BB%80%E4%B9%88%E6%98%AFredis/","excerpt":"","text":"什么是redis，有哪些特征基于内存（快） k，V （多数做缓存） 单线程（worker） ，iothreads 连接很多（连接池很多） ： nio多路复用（epoll） V：类型（5） 本地方法：计算向数据移动，IO优化 整体模型，串行化/原子操作： 并行 VS 串行谁更优 mamcachedk，v（string） 任何数据可以用json字符串存取，但数据传输一个整体，取某个值需要在本地计算 redis存： Ipush a “{a,b,c}”，识别数组 ，取 index(2)：具有本地方法，发指定下标取回指定的数据，计算在redis内 worker单线程 通过kernel :epoll 获取哪些数据可以读 （ io event） 主动去kernel获取客户端数据 （io读取，串行化） 6.x以后可以开启 iothreads （获取io数据时是多线程并行） 计算set get操作 （ 串行化） 使用场景Value: nosql String 字符串操作 数值计算 场景：session共享，kv缓存，计数器，fs文件系统（小文件，对磁盘io影响很大） （二进制）位运算 场景：bitmap 【任意统计】 统计一年用户登录天数（具体哪天），第五天 setbit 4 1 第365天 setbit 364 1 假如要派发礼品，统计活跃用户数 （数据过大做分桶）： setbit 20200101(日期) 8(id) 1(已登录) setbit 20200101(日期) 3(id) 1(已登录) setbit 20200102(日期) 8(id) 1(已登录) bitop or result 20200101 20200102；bitcount result（活跃用户数为 2） strlen 计算的是占用字节 具有二进制安全，byte[]类型 List value：双向链表；key：两个指针分别指向链表头尾（O(1)） 组合：同向 lpush lpop 栈；异向 lpush rpop 队列；lidex 数组；ltrim 优化redis 内存量 场景：评论列表；消息队列；替代 java 容器（map，list），让jvm无状态（挂了数据不丢失）、数据共享 hash hashtable 分治 场景：聚集数据（根据订单id查询 详情、评论、购买数 缓存起来）；表单详情页 set 集合：无序，不重复 场景： 集合交并差（交集：共同好友，差集：好友推荐）【不推荐：单线程，cpu密集型，阻塞其他操作，多实例：不同实例干不同的事】 随机事件（抽奖，验证码，扑克牌游戏）srandemember [count] 正数：返回不重复的集合，负数：返回可重复集合 sorted set（zset） 场景： 排行榜 评论：无序，分页 持久化redis 持久化 问题-&gt;分布式 cap/paxos/raft/akf RDB、image、bak 拍快照（时间点） 全量，丢失量比较大；体积相近内存大小；恢复速度取决于磁盘io速度-&gt;快 AOF 日志 趋向于实时；会丢数据 sync 性能下降 os：pagecache 丢失 5秒/ 10%内存（30%内存 阻塞） 每秒 AOF如果手动开启aof，在4.x以前，只会读取aof内容，不会读rdb 如果redis运行了10年，内存4g，AOF文件大小可以达到1T，因为他是追加命令。解决办法：重写（rewrite）：失效、无用、重复，条件满足后触发（4.x以前）。4.x以后：拍一个快照，然后在后面继续追加指令，RDB+AOF 解决问题辩证（快，内存）-&gt;当缓存：不建议开持久化-&gt;重启丢失数据-&gt;最快的缓存方案：1.RDB+AOF 2.主从复制 ​ -&gt;当数据库DB：AOFsync、主从强一致性-&gt;性能降低接近mysql 单点故障（不可用） 全量（主从复制）【高可用】 主备 压力/性能 扩容（分片），不是全量数据，全量主从复制 同步数据 强一致性：主从复制，会造成不可用性（CAP定理） 弱一致性：redis默认 最终一致性：主-&gt;黑盒（不会挂，强一致性）-&gt;从 开启强一致性，开启AOF、RDB，性能大降 最终一致性3台主机中至少两两通讯，如果断掉一台，添加数据可以成功，断掉的那台就不能对外提供服务，保证了数据强一致性。弱断掉的那台重新加入集群中，必须同步数据，后再对外提供服务 分布式锁redis、zookeeper、etcd 不靠谱，金融类 no；互联网类 yes","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://1194570458.github.io/tags/Redis/"}]},{"title":"JVM调优实战","slug":"JVM调优实战","date":"2020-05-23T13:45:22.000Z","updated":"2020-05-24T15:00:56.424Z","comments":true,"path":"2020/05/23/JVM调优实战/","link":"","permalink":"https://1194570458.github.io/2020/05/23/JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/","excerpt":"","text":"面试题大厂真题：2019年遇到的关于JVM GC的问题 GMS和G1的异同 - 百度 G1什么时候引发Full GC - 百度 说一个最熟悉的垃圾回收算法 - 百度 吞吐量优先和响应时间优先的回收器有哪些 - 百度 怎么判断内存泄漏 - 顺丰 讲一下CMS的流程 - 顺丰 为什么压缩指针超过32G失效 - 京东 什么是内存泄漏？GC调优有经验吗？一般出现GC问题你怎么解决？ - 淘宝 THreadLocal有没有内存写漏问题 - 阿里 蘑菇街（弱指针） G1两个Region不是连续的，而且之间还有可达的引用，我现在要回收一个，另一个怎么处理？ - 阿里（写屏障） 讲一下JVM堆内存管理（对象分配过程） - 阿里 听说过CMS的并发预处理和并发可中断预处理吗 - 阿里 到底多大的对象会被直接扔到老年代 - 阿里 用一句话说明你的JVM水平很牛 - 某个有病的企业 回收算法 Mark-Sweep（标记清除） 会产生碎片 Copying（拷贝） 内存浪费 Mark-Compact（标记压缩） 效率比copy低 常见的垃圾回收器Garbage Collectors（JDK 1.0 - JDK 14） 垃圾回收器的发展路线，是随着内存越来越大的过程而演进 从分代算法演化到不分代算法 Serial算法几十兆Parallel算法几个GCMS几十个G -承上启下，开始并发回收 三色标记-错标- Incremental Update - Remark G1上百G内存-逻辑分代，物理不分代 三色标记+SATB ZGC . Shenandoah - 4T -逻辑物理都不分代 ColoredPointer（颜色指针 着色指针） Epsilon -啥也不干(调试，确认不用GC参与就能干完活儿) JDK诞生Serial追随提高效率,诞生了PS,为了配合CMS,诞生了PN, CMS是1 .4版本后期引入，CMS是里程碑式的GC，它开启了并发回收的过程，但是CMS毛病较多,因此目前任何一个JDK版本默认是CMS并发垃圾回收是因为无法忍受STW Serial年轻代串行回收 PS年轻代并行回收 ParNew年轻代配合CMS的并行回收 SerialOld ParallelOld ConcurrentMarkSweep老年代并发的，垃圾回收和应用程序同时运行, 降低STW的时间(200ms)CMS问题比较多，所以现在没有一个版本默认是CMS，只能手工指定CMS既然是MarkSweep,就一-定会有碎片化的问题，碎片到达一定程度， CMS的老年代分配对象分配不下的时候，使用SerialOld 进行老年代回收想象-下:PS + PO -&gt;加内存换垃圾回收器-&gt; PN + CMS + SerialOld (几个小时-几天的STW)几十个G的内存，单线程回收-&gt; G1 + FGC几十个G -&gt;.上T内存的服务器ZGC算法:三色标记+ Incremental Update G1(200ms - 10ms)算法:三色标记+ SATB ZGC (10ms- 1ms) PK C++算法: ColoredPointers + LoadBarrier Shenandoah算法: ColoredPointers + WriteBarrier Eplison PS和PN区别的延伸阅读:https://docs.oracle.com/en/java/javase/13/gctuning/ergonomics.html#GUID-3D0BB91E-9BFF-4EBB-B523-1 4493A860E7314.垃圾收集器跟内存大小的关系 Serial几十兆 PS上百兆-几个G CMS- 20GI G1-上百G ZGC.4T- 16T UDK13) 1.8默认的垃圾回收: PS + ParallelOld 常见垃圾回收器组合参数设定: (1.8) -XX:+UseSerialGC = Serial New (DefNew) + Serial Old 小型程序。默认情况下不会是这种选项，HotSpot会根据计算及配置和DK版本自动选择收集器 -XX:+UseParNewGC = ParNew + SerialOld 这个组合已经很少用(在某些版本中已经废弃) https://stackoverflow.com/questions/34962257/why-remove-support-for-parnewserialold-anddefnewcms-in-the-future -XX:+UseConc(urrent)MarkSweepGC = ParNew + CMS + Serial Old -XX:+UseParallelGC = Parallel Scavenge + Parallel Old (1.8默认) [ PS + SerialOld] -XX:+UseParallelOldGC = Parallel Scavenge + Parallel Old -XX:+UseG1GC = G1 Linux中没找到默认GC的查看方法，而windows中会打印UseParallelGC java +XX:+PrintCommandLineFlags -version 通过GC的日志来分辨 Linux下1.8版本默认的垃圾回收器到底是什么? 1.8.0. .181默认(看不出来) Copy MarkCompact 1.8.0_222默认PS+PO 调优前的基础概念: 吞吐量:用户代码时间1 (用户代码执行时间+垃圾回收时间) 响应时间: STW越短，响应时间越好 所谓调优，首先确定，追求啥?吞吐量优先，还是响应时间优先?还是在满足一定的响应时间的情况下，要求达到 多大的吞吐量… 问题: 科学计算，吞吐量。数据挖掘，thrput。 吞吐量优先的一-般: (PS+ PO) 响应时间:网站GUIAPI (1.8G1) 什么是调优? 根据需求进行JVM规划和预调优 优化运行JVM运行环境(慢，卡顿) 解决JVM运行过程中出现的各种问题(O0M) JVM调优第一步，了解JVM常用命令行参数 JVM的命令行参数参考: https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html HotSpot参数分类 标准: - 开头,所有的HotSpot都支持 非标准: -X 开头，特定版本HotSpot支持特定命令 不稳定: -XX 开头，下个版本可能取消 java -version java -X 打印所有参数 java -XX:+PrintFlagsWithComments // 只有debug版本能用，编程debug版本jdk 试验用程序： 12345678910111213import java. util.List;import java. util.LinkedList;public class He11oGC &#123; public static void main(String[] args) &#123; System. out. print1n(\"He11oGC!\"); List list = new LinkedList(); for(;;) &#123; byte[] b = new byte [1024*1024]; list. add(b); &#125; &#125;&#125; 区分概念:内存泄漏memory leak,内存溢出out of memory java -XX:+ PrintCommandLineFlags HelloGC java -Xmn10M -Xms40M -Xmx60M -XX:+PrintCommandLineFlags -XX:+PrintGC HelloGCPrintGCDetails PrintGCTimeStamps PrintGCCauses java -XX:+UseConcMarkSweepGC -XX:+PrintCommandLineFlags HelloGC java -XX:+PrintFlagsInitial默认参数值 java -XX:+ PrintFlagsFinal最终参数值 java -XX:+PrintFlagsFinal | grep xxx找到对应的参数 java -XX:+PrintFlagsFinal -version |grep GC java -XX:+PrintFlagsFinal -version | WC-I共728个参数 PS GC日志详解每种垃圾回收器的日志格式是不同的. PS日志格式 heap dump部分: eden space 5632K， 94% used [000000000ff980000 , 00000000ffeb 3e28，0x0000000fff00000) 后面的内存地址指的是，起始地址，使用空间结束地址，整体空间结束地址 total = eden + 1个survivor 调优前的基础概念: 吞吐量:用户代码时间/ (用户代码执行时间+垃圾回收时间) 响应时间: STW越短,响应时间越好 所谓调优，首先确定，追求啥?吞吐量优先，还是响应时间优先?还是在满足一定的响应时间的情况下，要求达到多大的吞吐量… 问题: 科学计算，吞吐量。数据挖掘，thrput. 吞吐量优先的- -般: (PS+ PO) 响应时间:网站GUIAPI (1.8G1) 什么是调优? 根据需求进行JVM规划和预调优 优化运行JVM运行环境(慢，卡顿) 解决JVM运行过程中出现的各种问题(OOM) 调优，从规划开始 调优，从业务场景开始，没有业务场景的调优都是耍流氓 无监控(压力测试，能看到结果)，不调优 步骤: 熟悉业务场景(没有最好的垃圾回收器，只有最合适的垃圾回收器) 响应时间、停顿时间[CMS G1 ZGC] (需要给用户作响应) 吞吐量=用户时间/(用户时间+ GC时间) [PS] 选择回收器组合 计算内存需求(经验值1.5G 16G) 选定CPU (越高越好) 设定年代大小、升级年龄 设定日志参数 -Xlogg:/optxx/xx.xxx-gc-%t.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5-XX:GCLogFileSize=20M -XX:+PrintGCDetails -XX:+ PrintGCDateStamps -XX:+PrintGCCause 或者每天产生-个日志文件 观察日志情况 案例1:垂直电商，最高每日百万订单，处理订单系统需要什么样的服务器配置? 这个问题比较业余，因为很多不同的服务器配置都能支撑(1.5G 16G) 1小时360000集中时间段，100个订单秒， (找- -小时内的高峰期，1000订单/秒) 经验值, 非要计算: -一个订单产生需要多少内存? 512K * 1000 500M内存 专业一点儿问法:要求响应时间100ms 压测! . 案例2: 12306遭遇春节大规模抢票应该如何支撑? 12306应该是中国并发量最大的秒杀网站: 号称并发量100W最高 CDN -&gt; LVS .&gt; NGINX -&gt;业务系统-&gt;每台机器1W并发(10K问题) 100台机器 普通电商订单&gt;下单-&gt;订单系统(10) 减库存&gt;等待用户付款 12306的一种可能的模型:下单 &gt;减库存和订单(redis kafka)同时异步进行-&gt;等付款 减库存最后还会把压力压到一台服务器 可以做分布式本地库存+单独服务路做库存均衡 大流量的处理方法:分而治之 怎么得到一一个事务会消耗多少内存? 弄台机器，看能承受多少TPS？是不是达到目标？扩容或调优，让它达到 用压测来确定 优化环境 有一个50万PV的资料类网站(从磁盘提取文档到内存)原服务器32位, 1.5G的堆，用户反馈网站比较缓慢，因此公司决定升级，新的务器为64位，16G的堆内存，结果用户反馈卡顿十分严重,反而比以前效率更低了 为什么原网站慢? 很多用户浏览数据，很多数据load到内存,内存不足，频繁GC， STW长， 响应时间变慢 为什么会更卡顿? 内存越大，FGC时间越长 咋办? PS-&gt;PN+CMS或者G1 系统CPU经常100%，如何调优? (面试高频) CPU100%那么一定有线程在占用系统资源, 找出哪个进程cpu高(top) 该进程中的哪个线程cpu高(top -Hp) 导出该线程的堆栈(jstack) 查找哪个方法(栈帧)消耗时间(jstack) 工作线程占比高|垃圾回收线程占比高 系统内存飙高，如何查找问题? (面试高频) 导出堆内存(jmap) 分析(jhat jvisualvm mat jprofiler .. ) 如何监控JVM jstat jvisualvm jprofiler arthas top… 解决JVM运行中的问题一个案例理解常用工具 测试代码: . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.math.BigDecimal;import java.uti1.ArrayList;import java.util.Date;import java.uti1.List;import java.uti1.concurrent.scheduledThreadPoolExecutor;import java.util.concurrent.ThreadPoo1 Executor;import java.uti1.concurrent.TimeUnit;/*** 从数据库中读取信用数据，套用模型，并把结果进行记录和传输*//** * 风险评估 * @author Kason * date 2020-05-24 * * 可能导致频繁FullGZ 或者 OOM */public class FullGC_Problem01 &#123; private static class CardInfo &#123; BigDecimal price = new BigDecimal(0.0); String name = \"张三\"; int age = 5; Date birthdate = new Date(); public void m() &#123; &#125; &#125; private static ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(50,new ThreadPoolExecutor.DiscardOldestPolicy()); public static void main(String[] args) throws Exception &#123; executor.setMaximumPoolSize(50); for (;;)&#123; modelFit(); Thread.sleep(100); &#125; &#125; private static void modelFit() &#123; List&lt;CardInfo&gt; takeList = getAllCardInfo(); takeList.forEach(info -&gt;&#123; // do something executor.scheduleWithFixedDelay(()-&gt;&#123; // do sth with info info.m(); &#125;,2,3, TimeUnit.SECONDS); &#125;); &#125; private static List&lt;CardInfo&gt; getAllCardInfo() &#123; List&lt;CardInfo&gt; taskList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 100; i++) &#123; CardInfo ci =new CardInfo(); taskList.add(ci); &#125; return taskList; &#125;&#125; java -Xms200M -Xmx200M -XX:+PrintGC FullGC_Problem01 一般是运维团队首先受到报警信息(CPU Memory) top命令观察到问题:内存不断增长CPU占用率居高不下 top -Hp观察进程中的线程，哪个线程CPU和内存占比高 jps定位具体java进程jstack定位线程状况，重点关注: WAITING BLOCKEDeg.waiting on &lt;0000000088ca3310&gt; (a java.lang.Object)假如有一个进程中100个线程，很多线程都在waiting on ，一定要找到是哪个线程持有这把锁怎么找？搜索jstack dump的信息，找，看哪个线程持有这把锁RUNNABLE作业: 1：写一个死锁程序，用jstack观察 2：写一个程序,，一个线程持有锁不释放,其他线程等待 为什么阿里规范里规定，线程的名称(尤其是线程池)都要写有意义的名称怎么样自定义线程池里的线程名称? (自定 义ThreadFactory) jinfo pid jstat -gc 动态观察gc情况 / 阅读GC日志发现频繁GC / arthas观察 / jconsole/jvisualVM/ Jprofiler (最好用)jstat -gc 4655 500:每个500个毫秒打印GC的情况如果面试官问你是怎么定位00M问题的?如果你回答用图形界面(错误)1：已经上线的系统不用图形界面用什么? (cmdline arthas)2：图形界面到底用在什么地方?测试!测试的时候进行监控! (压测观察) jmap - histo 4655 | head -20，查找有多少对象产生 jmap -dump:format=b,file=xxx pid :线上系统，内存特别大, jmap执行期间会对进程产生很大影响，甚至卡顿(电商不适合)1：设定了参数HeapDump, 00M的时候会自动产生堆转储文件（不是很专业，因为多有监控，内存增长就会报警）2：很多服务器备份(高可用)，停掉这台服务器对其他服务器不影响3：在线定位(一般小点儿公司用不到) 4：在测试环境中压测(产生类似内存增长问题，在堆还不是很大的时候进行转储) java -Xms20M -Xmx20M -XX:+UseParallelGC -XX:+HeapDumpOnOutOfMemoryError FullGC_Problem01 使用MAT / jhat /jvisualvm 进行dump文件分析https://www.cnblogs.com/baihuitestsoftware/articles/6406271.htmljhat -J-mx512M xxx.dumphttp://192.168.17.11:7000拉到最后:找到对应链接可以使用OQL查找特定问题对象 找到代码的问题 arthas在线排查工具 为什么需要在线排查? 在生产上我们经常会碰到一些不好排查的问题，例如线程安全问题，用最简单的threaddump或者heapdump不好查到问题原因。为了排查这些问题，有时我们会临时加一-些日志， 比如在一些关键的函数里打印出入参,然后重新打包发布，如果打了日志还是没找到问题，继续加日志,重新打包发布。对于上线流程复杂而且审核比较严的公司，从改代码到上线需要层层的流转，会大大影响问题排查的进度。 jvm观察jvm信息 thread定位线程问题 dashboard 观察系统情况 heapdump + jhat分析 jad反编译 动态代理生成类的问题定位 第三方的类(观察代码) 版本问题(确定自己最新提交的版本是不是被使用) redefine 热替换 前有些限制条件:只能改方法实现(方法已经运行完成)，不能改方法名，不能改属性 m() -&gt; mm() sc-search class watch - watch method 没有包含的功能: jmap 案例汇总00M产生的原因多种多样，有些程序未必产生00M,不断FGC(CPU飙高，但内存回收特别少) (上面案例) 硬件升级系统反而卡顿的问题(见上) 线程池不当运用产生00M问题(见上) 不断的往List里加对象(实在太LOW) smile jira问题实际系统不断重启解决问题 加内存 + 更换垃圾回收器G1真正问题在哪儿?不知道 tomcat http-header-size过大问题(Hector) lambda表达式导致方法区溢出问题(MethodArea / Perm Metaspace)LambdaGC.java -XX:MaxMetaspaceSize=9M -XX:+PrintGCDetails 直接内存溢出问题(少见) 《深入理解]ava虚拟机》P59,使用Unsafe分配直接内存,或者使用NIO的问题 栈溢出问题 -Xss设定太小 比较一下这两段程序的异同， 分析哪-个是更优的写法: 12345678910Object o= nu11;for(int i=0; i&lt;100; 1++) &#123; o = new object(); //业务处理&#125;for(int i=0; i&lt;100; i++) &#123; Object o = new Object();&#125; 重写finalize引发频繁GC 小米云，HBase同步系统，系统通过nginx访问超时报警，最后排查, C++程序员重写finalize引发频繁GC问题 为什么C++程序员会重写finalize? (new delete) finalize耗时比较长(200ms) 如果有一个系统，内存一直消耗不超过10%，但是观察GC日志，发现FGC总是频繁产生，会是什么引起的? System.gc() (这个比较Low) Distuptor有个可以设置链的长度,如果过大,然后对象大，消费完不主动释放，会溢出(来自死物风情) 用jvm都会溢出，mycat用崩过，1.6.5某 个临时版本解析sq|子查询算法有问题，9个exists的联合sq|就导致生成几百万的对象(来自死物风情) new大量线程，会产生native thread 00M， (low) 应该用线程池，解决方案:减少堆空间(太TMlow了) ,预留更多内存产生native threadJVM内存占物理内存比例50% - 80% GC常用参数 -Xmn -Xms -Xmx -Xss 年轻代最小堆最大堆栈空间 -XX:+UseTLAB 使用TLAB,默认打开 -XX:+PrintTLAB 打印TL AB的使用情况 -XX:TL ABSize 设置TLAB大小. -XX:+ DisableExplictGC System.gc()不管用，FGC -XX:+PrintGC -XX:+PrintGCDetails -XX:+ PrintHeapAtGC -XX:+PrntGCTimeStamps -XX:+PrintGCApplicationConcurrentTime (低) 打印应用程序时间 -XX:+PrintGCApplicationStoppedTime (低) 打印暂停时长 -XX:+PrintReferenceGC (重要性低) 记录回收了多少种不同引用类型的引用 -verbose:class 类加载详细过程 -XX:+PrintVMOptions -XX:+PrintFlagsFinal -XX:+PrintFlagsInitial 必须会用 -Xloggc:opt/log/gc.log -XX:MaxTenuringThreshold 升代年龄，最大值15 锁自旋次数-XX:PreBlockSpin 热点代码检测参数-XX:CompileThreshold逃逸分析标量替换… 这些不建议设置 Parallel常用参数 -XX:SurvivorRatio -XX:PreTenureSizeThreshold 大对象到底多大 -XX:MaxTenuringThreshold -Xx:+ParallelGCThreads 并行收集器的线程数，同样适用于CMS,一般设为和CPU核数相同 -XX:+UseAdaptiveSizePolicy 自动选择各区大小比例 CMS常用参数 -XX:+UseConcMarkSweepGC -XX:ParallelCMSThreads CMS线程数量 -XX:CMSInitiatingOccupancyFraction 使用多少比例的老年代后开始CMS收集，默认是68%(近似值)， 如果频繁发生SerialOld卡顿,应该调小，(频繁CMS回收) -XX:+UseCMSCompactAtFullCollection 在FGC时进行压缩 -XX:CMSFulIGC sBeforeCompaction 多少次FGC之后进行压缩 -XX:+CMSClassUnloadingEnabled -XX:CMSInitiatingPermOccupancyFraction 达到什么比例时进行Perm回收 GCTimeRatio 设置GC时间占用程序运行时间的百分比 -XX:MaxGCPauseMillis 停顿时间，是-一个建议时间，GC会尝试用各种手段达到这个时间，比如减小年轻代 G1常用参数 -XX:+UseG1GC -XX:MaxGCPauseMillis 建议值，G1会尝试调整Young区的块数来达到这个值 -XX:GCPauseIntervalMillis ? GC的间隔时间 -XX:+G1 HeapRegionSize 分区大小，建议逐渐增大该值，1 248 1632. 随着size增加，垃圾的存活时间更长，GC间隔更长,但每次GC的时间也会更长 ZGC做了改进(动态区块大小) G1NewSizePercent 新生代最小比例，默认为5% G1MaxNewSizePercent 新生代最大比例，默认为60% GCTimeRatio GC时间建议比例，G1 会根据这个值调整堆空间 ConcGCThreads 线程数量 InitiatingHeapOccupancyPercent 启动G1的堆空间占用比例","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://1194570458.github.io/tags/JVM/"}]},{"title":"Docker-compose安装WordPress个人博客","slug":"Docker-compose安装WordPress博客","date":"2020-04-20T01:36:02.000Z","updated":"2020-04-20T01:55:09.995Z","comments":true,"path":"2020/04/20/Docker-compose安装WordPress博客/","link":"","permalink":"https://1194570458.github.io/2020/04/20/Docker-compose%E5%AE%89%E8%A3%85WordPress%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"创建 docker-compose.yml 文件创建 docker-compose.yml文件来分别启动你的 WordPress个人博客和挂载了持久卷的 MySQL实例 12345678910111213141516171819202122232425262728version: '3.3'services: db: image: mysql:5.7 volumes: - db_data:/var/lib/mysql restart: always environment: # 环境参数 MYSQL_ROOT_PASSWORD: somewordpress # 设置 root 用户的密码 MYSQL_DATABASE: wordpress # 创建 wordpress的数据库 MYSQL_USER: wordpress # 创建 wordpress用户 MYSQL_PASSWORD: wordpress # wordpress用户的密码 wordpress: depends_on: # 依赖db服务，需要等db服务运行后才运行wordpress服务 - db image: wordpress:latest ports: - \"8000:80\" restart: always environment: WORDPRESS_DB_HOST: db:3306 # 同一个 compose文件内，服务之间可以通过服务名互相通讯 WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: wordpress WORDPRESS_DB_NAME: wordpressvolumes: db_data: &#123;&#125; WordPress 所做的任何更新保存到数据库中，并持久化到数据卷db_data中，下次以后避免数据丢失 WordPress 需要占用80和443端口 运行项目123456789101112131415161718192021# 执行命令docker-compose up -d# 输出Creating network \"my_wordpress_default\" with the default driverPulling db (mysql:5.7)...5.7: Pulling from library/mysqlefd26ecc9548: Pull completea3ed95caeb02: Pull complete...Digest: sha256:34a0aca88e85f2efa5edff1cea77cf5d3147ad93545dbec99cfe705b03c520deStatus: Downloaded newer image for mysql:5.7Pulling wordpress (wordpress:latest)...latest: Pulling from library/wordpressefd26ecc9548: Already existsa3ed95caeb02: Pull complete589a9d9a7c64: Pull complete...Digest: sha256:ed28506ae44d5def89075fd5c01456610cd6c64006addfe5210b8c675881aff6Status: Downloaded newer image for wordpress:latestCreating my_wordpress_db_1Creating my_wordpress_wordpress_1 在你的浏览器中访问 WordPress WordPress 在宿主机的8000端口上运行 第一次运行需要稍等几分钟 在你的浏览器上输入 http://宿主机IP://8000 即可访问 WordPress","categories":[],"tags":[{"name":"Docker-compose","slug":"Docker-compose","permalink":"https://1194570458.github.io/tags/Docker-compose/"},{"name":"WordPress","slug":"WordPress","permalink":"https://1194570458.github.io/tags/WordPress/"}]},{"title":"Docker-compose尝新tomcat","slug":"Docker-compose尝新tomcat","date":"2020-04-20T01:27:01.000Z","updated":"2020-04-20T01:37:44.445Z","comments":true,"path":"2020/04/20/Docker-compose尝新tomcat/","link":"","permalink":"https://1194570458.github.io/2020/04/20/Docker-compose%E5%B0%9D%E6%96%B0tomcat/","excerpt":"","text":"新建 docker-compose.yml 文件123456789101112version: '3.1' # compose 文件版本services: # 服务 tomcat: # 服务名称 restart: always # 总是开机启动 image: tomcat # 镜像名称 container_name: tomcat # 容器名称 ports: #暴露的端口 - 8080:8080 volumes: # 映射目录，宿主机目录:容器目录 - ./data:/usr/local/tomcat/webapps/ROOT environment: # 环境参数 TZ: Asia/Shanghai 运行 docker-compose123docker-compose up # 直接运行docker-compose up -d # 后台运行","categories":[],"tags":[{"name":"Docker-compose","slug":"Docker-compose","permalink":"https://1194570458.github.io/tags/Docker-compose/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://1194570458.github.io/tags/Tomcat/"}]},{"title":"在Linux上安装Docker-compose","slug":"在Linux上安装Docker-compose","date":"2020-04-20T01:17:48.000Z","updated":"2020-04-20T03:22:51.913Z","comments":true,"path":"2020/04/20/在Linux上安装Docker-compose/","link":"","permalink":"https://1194570458.github.io/2020/04/20/%E5%9C%A8Linux%E4%B8%8A%E5%AE%89%E8%A3%85Docker-compose/","excerpt":"","text":"Docker-compose的Github https://github.com/docker/compose Docker-compose的安装文档 https://docs.docker.com/compose/install/ 安装 Docker-compose12345# 执行以下命令下载docker-composesudo curl -L \"https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose# 设置运行权限sudo chmod +x /usr/local/bin/docker-compose 测试是否安装成功1234docker-compose --version# 输出docker-compose version 1.25.5, build 1110ad01","categories":[],"tags":[{"name":"Docker-compose","slug":"Docker-compose","permalink":"https://1194570458.github.io/tags/Docker-compose/"},{"name":"Docker","slug":"Docker","permalink":"https://1194570458.github.io/tags/Docker/"},{"name":"Linux","slug":"Linux","permalink":"https://1194570458.github.io/tags/Linux/"}]},{"title":"在Linux上安装Docker","slug":"在Linux上安装Docker","date":"2020-04-20T01:06:41.000Z","updated":"2020-04-20T01:14:43.429Z","comments":true,"path":"2020/04/20/在Linux上安装Docker/","link":"","permalink":"https://1194570458.github.io/2020/04/20/%E5%9C%A8Linux%E4%B8%8A%E5%AE%89%E8%A3%85Docker/","excerpt":"","text":"Ubuntu安装docker安装系统工具12sudo apt-get updatesudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common 安装GPG证书1curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add - 写入软件源信息1sudo add-apt-repository \"deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable\" 更新软件源并安装docker12sudo apt-get -y updatesudo apt-get -y install docker-ce Centos安装docker安装依赖123$ sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 添加软件源123456789$ sudo yum-config-manager \\ --add-repo \\ https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo# 官方源# $ sudo yum-config-manager \\# --add-repo \\# https://download.docker.com/linux/centos/docker-ce.repo 配置安装最新docker 1sudo yum-config-manager --enable docker-ce-edge 安装12$ sudo yum makecache fast$ sudo yum install docker-ce 自动脚本安装12$ curl -fsSL get.docker.com -o get-docker.sh$ sudo sh get-docker.sh --mirror Aliyun 镜像加速配置文件 /etc/docker/daemon.json 123456789&#123; \"registry-mirrors\": [ \"https://registry.docker-cn.com\", \"https://3jc0zfhj.mirror.aliyuncs.com\" ], \"insecure-registries\": [ # 私有仓库地址 \"10.4.7.50\" ]&#125; 重启docker12sudo systemctl daemon-reloadsudo systemctl restart docker","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://1194570458.github.io/tags/Docker/"},{"name":"Linux","slug":"Linux","permalink":"https://1194570458.github.io/tags/Linux/"}]},{"title":"记录安装Docker","slug":"记录安装Docker","date":"2020-04-19T16:03:19.000Z","updated":"2020-04-19T16:06:52.375Z","comments":true,"path":"2020/04/20/记录安装Docker/","link":"","permalink":"https://1194570458.github.io/2020/04/20/%E8%AE%B0%E5%BD%95%E5%AE%89%E8%A3%85Docker/","excerpt":"","text":"DockerUbuntu安装docker安装系统工具12sudo apt-get updatesudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common 安装GPG证书1curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add - 写入软件源信息1sudo add-apt-repository \"deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable\" 更新软件源并安装docker12sudo apt-get -y updatesudo apt-get -y install docker-ce Centos安装docker安装依赖123$ sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 添加软件源123456789$ sudo yum-config-manager \\ --add-repo \\ https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo# 官方源# $ sudo yum-config-manager \\# --add-repo \\# https://download.docker.com/linux/centos/docker-ce.repo 配置安装最新docker 1sudo yum-config-manager --enable docker-ce-edge 安装12$ sudo yum makecache fast$ sudo yum install docker-ce 自动脚本安装12$ curl -fsSL get.docker.com -o get-docker.sh$ sudo sh get-docker.sh --mirror Aliyun 镜像加速配置文件 /etc/docker/daemon.json 123456789&#123; \"registry-mirrors\": [ \"https://registry.docker-cn.com\", \"https://3jc0zfhj.mirror.aliyuncs.com\" ], \"insecure-registries\": [ # 私有仓库地址 \"10.4.7.50\" ]&#125; 重启docker12sudo systemctl daemon-reloadsudo systemctl restart docker Docker-compose安装docker-compose12sudo curl -L https://github.com/docker/compose/releases/download/1.25.4/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-composesudo chmod +x /usr/local/bin/docker-compose docker-compose实战tomcat新建/usr/local/docker/tomcat目录 新建docker-compose.yml文件 123456789101112version: '3.1'services: tomcat: restart: always image: tomcat container_name: tomcat ports: - 8080:8080 volumes: - /usr/local/docker/tomcat/webapps/test:/usr/local/tomcat/webapps/test environment: TZ: Asia/Shanghai docker-compose实战mysql新建/usr/local/docker/mysql目录 新建docker-compose.yml文件 mysql5.7.221234567891011121314151617181920212223version: '3.1'services: mysql: restart: always image: mysql:5.7.22 container_name: mysql ports: - 3306:3306 environment: TZ: Asia/Shanghai MYSQL_ROOT_PASSWORD: 123456 command: --character-set-server=utf8mb4 --collation-server=utf8mb4_general_ci --explicit_defaults_for_timestamp=true --lower_case_table_names=1 --max_allowed_packet=128M --sql-mode=\"STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO\" volumes: - mysql-data:/var/lib/mysqlvolumes: mysql-data: mysql81234567891011121314151617181920212223version: '3.1'services: db: image: mysql restart: always environment: MYSQL_ROOT_PASSWORD: 123456 command: --default-authentication-plugin=mysql_native_password --character-set-server=utf8mb4 --collation-server=utf8mb4_general_ci --explicit_defaults_for_timestamp=true --lower_case_table_names=1 ports: - 3306:3306 volumes: - ./data:/var/lib/mysql adminer: image: adminer restart: always ports: - 8080:8080 GitLab安装gitlab docker-compose.yml ,如下: 123456789101112131415161718192021version: '3'services: gitlab: image: 'twang2218/gitlab-ce-zh' restart: always hostname: '10.4.7.50' environment: TZ: 'Asia/Shanghai' GITLAB_OMNIBUS_CONFIG: | external_url 'http://10.4.7.50' gitlab_rails['gitlab_shell_ssh_port'] = 2222 unicorn['port'] = 8888 nginx['listen_port'] = 80 ports: - '80:80' - '443:443' - '2222:22' volumes: - ./config:/etc/gitlab - ./data:/var/opt/gitlab - ./logs:/var/log/gitlab 访问地址：http://ip:80 GitLab基本配置账户与限制设置关闭 Gravatar头像 注册限制开启注册 免密登陆生成SSH KEY使用ssh-keygen工具生成，位置在git安装目录下，C:\\Program Files\\Git\\usr\\bin 输入命令 1ssh-keygen -t rsa -C \"your_email@example.com\" 添加ssh keygitlab-&gt;用户-&gt;设置-&gt;SSH密钥 标题：电脑标记 TortoiseGit修改ssh设置设置-&gt;网络-&gt;ssh客户端 修改为 git安装目录-&gt;usr-&gt;bin-&gt;ssh Nexus （依赖管理平台）安装nexus新建/usr/local/docker/nexus目录 新建docker-compose.yml文件 12345678910111213version: '3.1'services: nexus: restart: always image: sonatype/nexus3 container_name: nexus ports: - 8082:8081 volumes: - nexus-data:/nexus-data volumes: nexus-data: 登陆控制台地址: http://ip:port 用户名: admin 密码: admin123 修改maven仓库为私服在 Maven settings.xml 中添加 Nexus 认证信息(servers 节点下)： 1234567891011&lt;server&gt; &lt;id&gt;nexus-releases&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt;&lt;server&gt; &lt;id&gt;nexus-snapshots&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt; 配置自动化部署在 pom.xml 中添加如下代码： 123456789101112&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;nexus-releases&lt;/id&gt; &lt;name&gt;Nexus Release Repository&lt;/name&gt; &lt;url&gt;http://127.0.0.1:8082/repository/maven-releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;nexus-snapshots&lt;/id&gt; &lt;name&gt;Nexus Snapshot Repository&lt;/name&gt; &lt;url&gt;http://127.0.0.1:8082/repository/maven-snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt; &lt;/distributionManagement&gt; 注意事项： ID 名称必须要与 settings.xml 中 Servers 配置的 ID 名称保持一致。 项目版本号中有 SNAPSHOT 标识的，会发布到 Nexus Snapshots Repository, 否则发布到 Nexus Release Repository，并根据 ID 去匹配授权账号。 部署到仓库1mvn deploy 上传第三方 JAR 包123456789# 如第三方JAR包：aliyun-sdk-oss-2.2.3.jarmvn deploy:deploy-file -DgroupId=com.aliyun.oss -DartifactId=aliyun-sdk-oss -Dversion=2.2.3 -Dpackaging=jar -Dfile=D:\\aliyun-sdk-oss-2.2.3.jar -Durl=http://127.0.0.1:8081/repository/maven-3rd/ -DrepositoryId=nexus-releases 注意事项： 建议在上传第三方 JAR 包时，创建单独的第三方 JAR 包管理仓库，便于管理有维护。（maven-3rd） -DrepositoryId=nexus-releases 对应的是 settings.xml 中 Servers 配置的 ID 名称。（授权） 配置代理仓库1234567891011121314151617181920212223242526&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;Nexus Repository&lt;/name&gt; &lt;url&gt;http://127.0.0.1:8081/repository/maven-public/&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;/repository&gt;&lt;/repositories&gt;&lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;Nexus Plugin Repository&lt;/name&gt; &lt;url&gt;http://127.0.0.1:8081/repository/maven-public/&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;/pluginRepository&gt;&lt;/pluginRepositories&gt; 安装Docker Registry私服安装新建/usr/local/docker/registry目录 新建docker-compose.yml文件 12345678910version: '3.1'services: registry: image: registry restart: always container_name: registry ports: - 5000:5000 volumes: - ./data:/var/lib/registry 地址 http://ip:5000/v2/ 配置私服客户端编辑/etc/docker/daemon.json文件 12345678&#123; \"registry-mirrors\": [ \"https://registry.docker-cn.com\" ], \"insecure-registries\": [ \"ip:5000\" ]&#125; 重启服务 12$ sudo systemctl daemon-reload$ sudo systemctl restart docker 检查客户端配置是否生效使用 docker info 命令手动检查，如果从配置中看到如下内容，说明配置成功（192.168.75.133 为教学案例 IP） 123Insecure Registries: 192.168.75.133:5000 127.0.0.0/8 测试镜像上传我们以 Nginx 为例测试镜像上传功能 1234567891011## 拉取一个镜像docker pull nginx## 查看全部镜像docker images## 标记本地镜像并指向目标仓库（ip:port/image_name:tag，该格式为标记版本号）docker tag nginx 192.168.75.133:5000/nginx## 提交镜像到仓库docker push 192.168.75.133:5000/nginx 查看全部镜像1curl -XGET http://192.168.75.133:5000/v2/_catalog 查看指定镜像以 Nginx 为例，查看已提交的列表 1curl -XGET http://192.168.75.133:5000/v2/nginx/tags/list 测试拉取镜像 先删除镜像 12docker rmi nginxdocker rmi 192.168.75.133:5000/nginx 再拉取镜像 1docker pull 192.168.75.133:5000/nginx 部署Docker Registry WebUI私服安装成功后就可以使用 docker 命令行工具对 registry 做各种操作了。然而不太方便的地方是不能直观的查看 registry 中的资源情况。如果可以使用 UI 工具管理镜像就更好了。这里介绍两个 Docker Registry WebUI 工具 docker-registry-frontend docker-registry-web 两个工具的功能和界面都差不多，我们以 docker-registry-fontend 为例讲解 docker-registry-frontend新建/usr/local/docker/webui目录 新建docker-compose.yml 123456789101112version: '3.1'services: frontend: image: konradkleine/docker-registry-frontend:v2 ports: - 8080:80 volumes: - ./certs/frontend.crt:/etc/apache2/server.crt:ro - ./certs/frontend.key:/etc/apache2/server.key:ro environment: - ENV_DOCKER_REGISTRY_HOST=192.168.75.133 - ENV_DOCKER_REGISTRY_PORT=5000 地址：http://ip:8080 安装Harbor私有仓库GitHub地址：https://github.com/goharbor/harbor/releases 配置证书12345678openssl genrsa -des3 -out server.key 2048openssl req -new -key server.key -out server.csrcp server.key server.key.orgopenssl rsa -in server.key.org -out server.keyopenssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crtmkdir /data/cert -pmv server.* /data/certchmod -R 777 /data/cert 修改harbor.cfg hostname=域名 ui_url_protocol = https db_password = 数据库密码 harbor_admin_password = 123456 访问 hostname:80 账号：admin 密码：123456 登录到私有仓库docker login hostname Docker 安装WordPress个人博客运行环境 PHP 5.6 或更新软件 MySQL 5.6或 更新版本 Apache 和 mod_rewrite 模块 安装教程直接安装12docker run --name db -e MYSQL_ROOT_PASSWORD=example -d mariadbdocker run --name MyWordPress --link db:mysql -p 8080:80 -d workpress 使用Docker-compose安装123456789101112131415161718192021version '3'service: db: image: mysql:5.7 restart: always environment: MYSQL_ROOT_PASSWORD: somewordpress MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: wordpress wordpress: depends_on: #依赖db - db image: wordpress restart: always ports: - 8080:80 environment: WORDPRESS_DB_HOST: db:3306 WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: wordpress Docker内存限制 –memory-swap –memory 功能 正数S 正数M 容器可用总空间为S，其中ram为M，swap为（S-M），若S=M，则无可用swap资源 0 正数M 相当于未设置swap（unset） unset 正数M 若主机（Docker Host）启用了swap，则容器的可用swap为2*M -1 正数M 若注意（Docker Host）启用了swap，则容器可使用最大至主机上的所有swap空间的swap资源 Docker 清除虚悬镜像123docker rmi $(docker images -f \"dangling=true\" -q)# 或者docker image prune -a -f Docker-Compose 网络设置12345# 创建网络docker create network my_network# 查看已存在的网络docke network list 添加配置12345# docker-compose.ymlnetwork: default: external: name: my_network","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://1194570458.github.io/tags/Docker/"}]}],"categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://1194570458.github.io/tags/JVM/"},{"name":"Java","slug":"Java","permalink":"https://1194570458.github.io/tags/Java/"},{"name":"Synchronized","slug":"Synchronized","permalink":"https://1194570458.github.io/tags/Synchronized/"},{"name":"Redis","slug":"Redis","permalink":"https://1194570458.github.io/tags/Redis/"},{"name":"Docker-compose","slug":"Docker-compose","permalink":"https://1194570458.github.io/tags/Docker-compose/"},{"name":"WordPress","slug":"WordPress","permalink":"https://1194570458.github.io/tags/WordPress/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://1194570458.github.io/tags/Tomcat/"},{"name":"Docker","slug":"Docker","permalink":"https://1194570458.github.io/tags/Docker/"},{"name":"Linux","slug":"Linux","permalink":"https://1194570458.github.io/tags/Linux/"}]}